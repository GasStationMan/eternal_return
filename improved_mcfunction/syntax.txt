아래는 대체사용 가능 명령어

scoreboard players operation == op
scoreboard players set       == set
scoreboard players add       == add
scoreboard players remove    == sub
scoreboard players get       == get
scoreboard players reset     == reset   


고급 객체화

고급 객체화가 이루어진 storage 변수의 경우, [](인덱싱) 과 .(엘리먼트 추가)를 즉각적으로 할 수 있다.
storage STR is minecraft:test test
STR.elementA = 10
STR.elementB = [11,12,13]
i = STR.elementB[1]
-> data modify minecraft.test test.elementA set value 10

entity THIS is @s[tag=A,tag=B,tag=C]
-> execute as THIS run say hi

score i is #i ANYscoreboard
-> add i 1



고급 객체화가 이루어진 변수들은 서로 대입이 가능하다.
STR.elementA = THIS UUID
i = THIS UUID[0]
STR.i = i

코드 블록 선언
코드 블록의 경우 function : 으로 선언 가능하다
매크로를 사용해야 하는 경우, function {<MacroEXP>} : 또는 function with <고급 객체화 된 스토리지 변수> : 로 선언이 가능하다.

while 문 만들기

score i is #i scoreboardYouWantToName
storage FUNCTIONNAME is minecraft:temp temp
FUNCTIONNAME.i = i

i = 0
function with FUNCTIONNAME:
    $say hi $(i)
    i += 1
    FUNCTIONNAME.i = i
    if i matches ..10 function BACK :


def와 import의 차이

def의 경우는 함수의 이름을 바꿔주고 맨 뒤에 main을 붙인다
import의 경우에는 함수의 이름을 바꾸기만 한다.

















@Entity
def entityDetectHitboxRaycast():

    vec3 pPos = this.df_lib:float4.vec3d.getPlayerPos();
    vec3 pDir = this.df_lib:float4.vec3d.getPleyerDir();

    execute as @e[type=minecraft:interaction] at @s rotated as @s positioned ^ ^ ^1 -> :
        int isIntersect = 0;
        isIntersect = df_lib:float4.vec3d.detectInfPlane(this.pxNormvec,this.pxObjpos,pPos,pDir);
        if isIntersect

<macro> int x -> scoreboard players add x dummy
<macro> float4 x -> scoreboard players add x dummy

class vec3 :
    float4 x 
    float4 y 
    float4 z


func getDotProduct(vec3 v31, vec3 v32) -> vec3:
    return float4 v31.x*v32.x + v31.y*v32.y + v31.z*v32.z


tick func main() -> int:
    execute as @e[type=minecraft:marker] :
        vec3 pos[@s] = [0,0,0]
        pos[@s] = f4.v3.normalize(pos[@s] - pos[@e[tag=before]])
        float4 dotPRD = getDotProduct(pos[@s])
    
    



---[vv COMPILE INTO vv]--->

scoreboard players add vec3.x dummy
scoreboard players add vec3.y dummy
scoreboard players add vec3.z dummy

{getDotProduct} :
mov 


tick.json->main :
execute as @e[type=minecraft:marker] run function dir/../code -> block
dir/../code
start
mov @s vec3.pos.x 0
mov @s vec3.pos.y 0
mov @s vec3.pos.z 0
function [df_lib:f4.v3.getPlayerPos]
op @s vec3.pos.x = #[df_lib:f4/v3/get_player_pos] vec3.pos.x
op @s vec3.pos.y = #[df_lib:f4/v3/get_player_pos] vec3.pos.y
op @s vec3.pos.z = #[df_lib:f4/v3/get_player_pos] vec3.pos.z
op #[df_lib:f4.v3.normalize].x vec3.x = @s vec3.pos.x
op #[df_lib:f4.v3.normalize].y vec3.y = @s vec3.pos.x
op #[df_lib:f4.v3.normalize].z vec3.z = @s vec3.pos.x
function [df_lib:f4.v3.normalize]
op @s vec3.x = #[df_lib:f4/v3/get_player_pos] vec3.x
op @s vec3.y = #[df_lib:f4/v3/get_player_pos] vec3.y
op @s vec3.z = #[df_lib:f4/v3/get_player_pos] vec3.z
end


projectName : <projectName>

 


    





function drawLine(e entity, int a, int b) {}


function_def_raw:
    | 'def' NAME [type_params] '(' [params] ')' ['->' expression ] ':' [func_type_comment] block 
    | ASYNC 'def' NAME [type_params] '(' [params] ')' ['->' expression ] ':' [func_type_comment] block 


<start_exp> -> <exp>
<exp> -> <func_def>
         <func_def> -> function <func_name> ( <func_param> ) { <block> }
            <func_name> -> <id>
            <func_param> -> <assign> , ...
                         -> <assign> , <func_param>
                         -> NULL
            
























1. 같은 조건 하에서 실행되는 커맨드의 경우 함수로 묶는다.
	ex :
        execute if entity @s[tag=callFuncAfter] run ...
        execute if entity @s[tag=callFuncAfter] run ...
        execute if entity @s[tag=callFuncAfter] run ...
        execute if entity @s[tag=callFuncAfter] run ...
        execute if entity @s[tag=callFuncAfter] run ...
        execute if entity @s[tag=callFuncAfter] run ...
        
        ..를 다음으로 변경
        
        execute if entity @s[tag=callFuncAfter] run function branch

        branch:
            ...
            ...
            ...
            ...
            ...

2. 절대 execute as @a나 @e를 남발하지 않는다. execute as 한 번 호출에 무시하지 못할 속도 저하가 일어난다.
    ex :
        execute as @e run ...
        execute as @e run ...
        execute as @e run ...
        execute as @e run ...
        execute as @e run ...
        execute as @e run ...
        
        ..를 다음으로 변경

        execute as @e run function branch

        branch : 
                ...
                ...
                ...
                ...
                ...
                ...

3. 절대 execute as @e[nbt={...}] 나 execute as @a[nbt={...}]를 사용하지 말 것. 마찬가지로 execute if entity @a[nbt={...}] 나 execute if entity @e[nbt={...}]를 사용하지 말 것. 대신 execute if data를 사용한다.
    ex : 
        execute if entity @a[nbt={...}]       -> X
        execute as @a[nbt={...}]              -> X

        ..를 다음으로 변경

        execute if data entity @a {...}       -> O
        execute as @a if data entity @s {...} -> O





















